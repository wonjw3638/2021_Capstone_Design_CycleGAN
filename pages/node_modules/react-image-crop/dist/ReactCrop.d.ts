import React, { PureComponent } from 'react';
import './ReactCrop.scss';
declare function makeAspectCrop(crop: Crop, imageWidth: number, imageHeight: number): Crop;
declare function containCrop(prevCrop: Partial<Crop>, crop: Partial<Crop>, imageWidth: number, imageHeight: number): Crop;
declare type XOrds = 'e' | 'w';
declare type YOrds = 'n' | 's';
declare type XYOrds = 'nw' | 'ne' | 'se' | 'sw';
declare type Ords = XOrds | YOrds | XYOrds;
export interface Crop {
    aspect?: number;
    x: number;
    y: number;
    width: number;
    height: number;
    unit: 'px' | '%';
}
interface EVData {
    clientStartX: number;
    clientStartY: number;
    cropStartWidth: number;
    cropStartHeight: number;
    cropStartX: number;
    cropStartY: number;
    xDiff: number;
    yDiff: number;
    xInversed: boolean;
    yInversed: boolean;
    xCrossOver: boolean;
    yCrossOver: boolean;
    lastYCrossover: boolean;
    startXCrossOver: boolean;
    startYCrossOver: boolean;
    isResize: boolean;
    ord: Ords;
}
export interface ReactCropProps {
    /** A string of classes to add to the main `ReactCrop` element. */
    className?: string;
    /** A React Node that will be inserted into the `ReactCrop` element */
    children?: React.ReactNode;
    /** Show the crop area as a circle. If your aspect is not 1 (a square) then the circle will be warped into an oval shape. Defaults to false. */
    circularCrop?: boolean;
    /** All crop params are initially optional. See README.md for more info. */
    crop: Partial<Crop>;
    /** Allows setting the crossorigin attribute on the image. */
    crossorigin?: React.DetailedHTMLProps<React.ImgHTMLAttributes<HTMLImageElement>, HTMLImageElement>['crossOrigin'];
    /** If true then the user cannot resize or draw a new crop. A class of `ReactCrop--disabled` is also added to the container for user styling. */
    disabled?: boolean;
    /** If true then the user cannot create or resize a crop, but can still drag the existing crop around. A class of `ReactCrop--locked` is also added to the container for user styling. */
    locked?: boolean;
    /** Add an alt attribute to the image element. */
    imageAlt?: string;
    /** Inline styles object to be passed to the image element. */
    imageStyle?: React.CSSProperties;
    /** If true is passed then selection can't be disabled if the user clicks outside the selection area. */
    keepSelection?: boolean;
    /** A minimum crop width, in pixels. */
    minWidth?: number;
    /** A minimum crop height, in pixels. */
    minHeight?: number;
    /** A maximum crop width, in pixels. */
    maxWidth?: number;
    /** A maximum crop height, in pixels. */
    maxHeight?: number;
    /** A callback which happens for every change of the crop. You should set the crop to state and pass it back into the library via the `crop` prop. */
    onChange: (crop: Crop, percentageCrop: Crop) => void;
    /** A callback which happens after a resize, drag, or nudge. Passes the current crop state object in pixels and percent. */
    onComplete?: (crop: Crop, percentageCrop: Crop) => void;
    /** This event is called if the image had an error loading. */
    onImageError?: React.DOMAttributes<HTMLImageElement>['onError'];
    /** A callback which happens when the image is loaded. Passes the image DOM element. Return false if you set the crop with setState in there as otherwise the subsequent onChange + onComplete will not have your updated crop. */
    onImageLoaded?: (image: HTMLImageElement) => void | boolean;
    /** A callback which happens when a user starts dragging or resizing. It is convenient to manipulate elements outside this component. */
    onDragStart?: (e: PointerEvent) => void;
    /** A callback which happens when a user releases the cursor or touch after dragging or resizing. */
    onDragEnd?: (e: PointerEvent) => void;
    /** Render a custom HTML element in place of an image. Useful if you want to support videos. */
    renderComponent?: React.ReactNode;
    /** Render a custom element in crop selection. */
    renderSelectionAddon?: (state: ReactCropState) => React.ReactNode;
    /** Rotates the image, you should pass a value between -180 and 180. Defaults to 0. */
    rotate?: number;
    /** Show rule of thirds lines in the cropped area. Defaults to false. */
    ruleOfThirds?: boolean;
    /** Scales the image. Defaults to 1 (normal scale). */
    scale?: number;
    /** The image source (can be base64 or a blob just like a normal image). */
    src: string;
    /** Inline styles object to be passed to the image wrapper element. */
    style?: React.CSSProperties;
    /** A non-visual prop to keep pointer coords accurate when a parent element is scaled. Not to be confused with the `scale` prop which scales the image itself. Defaults to 1. */
    zoom?: number;
    /** A non-visual prop to keep pointer coords accurate when a parent element is rotated. Not to be confused with the `rotate` prop which rotates the image itself. Defaults to 0, range is from -180 to 180. */
    spin?: number;
}
export interface ReactCropState {
    cropIsActive: boolean;
    newCropIsBeingDrawn: boolean;
}
declare class ReactCrop extends PureComponent<ReactCropProps, ReactCropState> {
    static xOrds: string[];
    static yOrds: string[];
    static xyOrds: string[];
    static nudgeStep: number;
    static nudgeStepMedium: number;
    static nudgeStepLarge: number;
    keysDown: Set<string>;
    docMoveBound: boolean;
    mouseDownOnCrop: boolean;
    dragStarted: boolean;
    evData: EVData;
    componentRef: React.RefObject<HTMLDivElement>;
    mediaWrapperRef: React.RefObject<HTMLDivElement>;
    imageRef: React.RefObject<HTMLImageElement>;
    cropSelectRef: React.RefObject<HTMLDivElement>;
    state: ReactCropState;
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: ReactCropProps): void;
    bindDocMove(): void;
    unbindDocMove(): void;
    onCropPointerDown: (e: React.PointerEvent<HTMLDivElement>) => void;
    onComponentPointerDown: (e: React.PointerEvent<HTMLDivElement>) => void;
    onDocPointerMove: (e: PointerEvent) => void;
    onComponentKeyDown: (e: React.KeyboardEvent<HTMLDivElement>) => void;
    onComponentKeyUp: (e: React.KeyboardEvent<HTMLDivElement>) => void;
    onDocPointerDone: (e: PointerEvent) => void;
    createNewCrop(): {
        pixelCrop: Crop;
        percentCrop: Crop;
    };
    onMediaLoaded: () => void;
    onImageLoad: (e: React.SyntheticEvent<HTMLImageElement, Event>) => void;
    get mediaDimensions(): {
        width: number;
        height: number;
    };
    getCropStyle(): {
        top: string;
        left: string;
        width: string;
        height: string;
    };
    getNewSize(): {
        width: number;
        height: number;
    };
    dragCrop(): Crop;
    resizeCrop(): Partial<Crop>;
    getRotatedCursor(handle: string, degrees: number): {
        cursor: string;
    } | undefined;
    createCropSelection(): JSX.Element;
    makeNewCrop(unit?: string): Crop;
    crossOverCheck(): void;
    render(): JSX.Element;
}
export { ReactCrop as default, ReactCrop as Component, makeAspectCrop, containCrop };
